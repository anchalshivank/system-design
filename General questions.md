### **System Design Cheat Sheet**

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| **Protocols**                      | Rules defining how data is exchanged between systems.                            |                                                                                  |                                                                                           |                                                                                                     |
| HTTP/HTTPS                         | Protocol for web communication, HTTPS adds encryption.                           | REST APIs, Web Services                                                          | Standard, stateless, widely supported.                                                    | Use libraries like `axios` (Node.js) or frameworks like Flask/Django; secure with TLS (e.g., OpenSSL). |
| HTTP/2                             | Enhanced HTTP with performance improvements.                                     | High-performance APIs                                                            | Multiplexing, header compression, reduced latency.                                        | Deploy with modern web servers (e.g., Nginx, Apache) supporting HTTP/2.                              |
| gRPC                               | High-performance RPC protocol using HTTP/2 and Protocol Buffers.                 | Microservices, RPC                                                               | Fast, binary, supports streaming, multilingual.                                           | Use gRPC libraries (e.g., gRPC-Go, gRPC-Java) with Protocol Buffers for schema definition.            |
| WebSockets                         | Persistent, full-duplex communication over a single connection.                  | Real-time apps (e.g., chat, live updates)                                        | Low-latency, bidirectional communication.                                                 | Implement with libraries like `Socket.IO` (Node.js) or `ws` (WebSocket server).                      |
| MQTT                               | Lightweight pub/sub protocol for small devices.                                  | IoT, real-time messaging                                                         | Efficient for low-bandwidth/unreliable networks.                                          | Use MQTT brokers (e.g., Mosquitto) and clients (e.g., Paho MQTT).                                    |
| AMQP                               | Protocol for reliable message queuing and routing.                               | Reliable messaging (e.g., RabbitMQ)                                              | Guaranteed delivery, complex routing.                                                     | Deploy with RabbitMQ or ActiveMQ; configure queues/exchanges via AMQP clients.                       |
| Kafka Protocol                     | Distributed streaming protocol for event logs.                                   | High-throughput event streaming                                                  | Scalable, durable, fault-tolerant data pipelines.                                         | Use Apache Kafka with producers/consumers (e.g., Kafka-Python, Kafka-Java).                          |
| GraphQL                            | Query language protocol for flexible API data fetching.                          | Flexible APIs (e.g., GitHub API)                                                 | Reduces over/under-fetching, client-driven.                                               | Implement with Apollo Server (Node.js) or Graphene (Python); define schemas for queries.             |
| **Server Software/Services**       | Software or services running on servers to handle specific tasks.                |                                                                                  |                                                                                           |                                                                                                     |
| SMTP (via Mail Servers)            | Protocol for email, implemented by mail server software.                         | Postfix, Sendmail (for Gmail, Outlook integration)                               | Standard for email delivery.                                                              | Configure mail servers with SMTP settings; use libraries like `nodemailer` for programmatic sending. |
| FTP/SFTP (via File Servers)        | Protocols for file transfer, SFTP adds security; implemented by file servers.    | FileZilla Server, OpenSSH (SFTP)                                                 | FTP for basic transfers, SFTP for secure transfers.                                       | Set up FTP/SFTP servers (e.g., vsftpd, OpenSSH); use clients like `scp` or FileZilla.                 |
| RTMP (via Streaming Servers)       | Protocol for real-time video, used by streaming servers.                         | Nginx-RTMP, Wowza                                                                | Low-latency video streaming (e.g., Twitch).                                               | Configure Nginx with RTMP module or use Wowza; stream with tools like OBS.                           |
| SNS                                | Managed service for push notifications, not a protocol.                          | AWS SNS                                                                          | Scalable, multi-platform (SMS, iOS, Android).                                             | Integrate via AWS SDK (e.g., boto3 in Python); configure topics/subscribers.                         |
| NFS                                | Network file system for shared storage, implemented by servers.                  | NFS Server (Linux)                                                               | Enables shared file access across servers.                                                | Set up NFS on Linux (e.g., `nfs-kernel-server`); mount on clients with `mount -t nfs`.               |
| **Databases**                      | Systems for storing and retrieving data.                                         |                                                                                  |                                                                                           |                                                                                                     |
| Relational (SQL)                   | Structured data with tables and schemas.                                         | PostgreSQL, MySQL                                                                | ACID compliance, strong consistency (e.g., banking).                                      | Use ORMs (e.g., SQLAlchemy, Hibernate) or raw SQL; deploy on RDS or local servers.                   |
| NoSQL (Key-Value)                  | Simple key-value pair storage.                                                   | Redis, DynamoDB                                                                  | Fast lookups, caching, session storage.                                                   | Deploy Redis locally or use AWS DynamoDB; access via clients (e.g., `redis-py`).                     |
| NoSQL (Document)                   | Semi-structured data in JSON-like documents.                                    | MongoDB, CouchDB                                                                 | Flexible schema, hierarchical data (e.g., CMS).                                           | Use MongoDB Atlas or local instance; query with drivers (e.g., PyMongo).                             |
| NoSQL (Columnar)                   | Wide-column storage for analytics.                                               | Apache Cassandra, Bigtable                                                       | Large-scale analytics, time-series (e.g., recommendations).                               | Deploy Cassandra cluster; use CQL (Cassandra Query Language) via drivers.                            |
| NoSQL (Graph)                      | Node-edge structure for relationships.                                           | Neo4j, ArangoDB                                                                  | Complex relationships (e.g., social networks).                                            | Run Neo4j locally or on cloud; query with Cypher (Neo4j) or AQL (ArangoDB).                          |
| Time-Series                        | Specialized DB for time-stamped data.                                            | InfluxDB, TimescaleDB                                                            | Optimized for IoT, monitoring data.                                                       | Deploy InfluxDB or extend PostgreSQL with TimescaleDB; use client libraries (e.g., InfluxDB-Python).  |
| **Caching**                        | Temporary storage for fast data access.                                          |                                                                                  |                                                                                           |                                                                                                     |
| Cache-aside                        | App manages cache, fetches from DB if miss.                                      | Redis, Memcached                                                                 | Reduces DB load, general-purpose caching.                                                 | Implement with Redis client (e.g., `redis-py`); app logic checks cache, updates on miss.             |
| Write-through                      | Writes go to cache and DB simultaneously.                                        | Redis                                                                            | Ensures cache-DB sync (read-heavy workloads).                                             | Use Redis with write-through logic in app (e.g., update cache and DB in one transaction).            |
| Write-behind                       | Writes to cache first, DB synced later.                                          | Redis                                                                            | Reduces DB write load (high-write, eventual consistency).                                 | Configure Redis with async DB sync (e.g., background job with Celery or Kafka).                      |
| Read-through                       | Cache fetches from DB automatically on miss.                                     | CDN, API Gateway                                                                 | Simplifies app logic (e.g., CDN caching).                                                 | Use AWS API Gateway caching or CDN (e.g., Cloudflare) with auto-fetch setup.                         |
| Distributed Cache                  | Cache spread across multiple nodes.                                              | Hazelcast, Redis Cluster                                                         | Scales caching for high availability/performance.                                         | Deploy Redis Cluster or Hazelcast; configure with consistent hashing.                                |
| Eviction Strategy                  | Rules for removing old cache data.                                               | LRU, LFU, TTL                                                                    | LRU for recent use, LFU for frequency, TTL for time.                                      | Set in Redis (e.g., `CONFIG SET maxmemory-policy allkeys-lru`) or Memcached config.                  |
| **Scaling**                        | Increasing system capacity.                                                      |                                                                                  |                                                                                           |                                                                                                     |
| Horizontal Scaling                 | Add more machines to distribute load.                                            | Microservices, Sharding                                                          | Scales out (e.g., Instagram, Twitter).                                                    | Use Kubernetes for microservices; shard DB with tools like Vitess.                                   |
| Vertical Scaling                   | Upgrade single machine (CPU, RAM, etc.).                                         | Single powerful machine                                                          | Simplifies scaling for compute/memory/I/O (e.g., legacy apps).                            | Upgrade hardware or cloud instance (e.g., AWS EC2 t3.large → t3.xlarge).                             |
| Load Balancing                     | Distribute traffic across servers.                                               | Nginx, HAProxy                                                                   | Ensures reliability and performance.                                                      | Configure Nginx/HAProxy with round-robin or least-connection algorithms.                             |
| Database Sharding                  | Split DB across multiple servers.                                                | Vitess (MySQL), Citus (PostgreSQL)                                               | Handles write-heavy systems.                                                              | Use Vitess for MySQL sharding or Citus for PostgreSQL; define shard keys.                            |
| **Messaging & Queues**             | Systems for asynchronous communication.                                          |                                                                                  |                                                                                           |                                                                                                     |
| Message Queue                      | Buffer for tasks/messages between systems.                                       | Kafka, RabbitMQ                                                                  | Kafka for streaming/durability; RabbitMQ for queuing.                                     | Deploy Kafka cluster or RabbitMQ; use clients (e.g., `confluent-kafka`, `pika`).                     |
| Event-Driven Architecture          | Systems react to events in real-time.                                            | Kafka, AWS Lambda                                                                | Real-time processing (e.g., Uber tracking).                                               | Set up Kafka topics or Lambda triggers; process events with consumers.                               |
| Pub/Sub                            | Publishers send to subscribers via topics.                                       | Google Pub/Sub, Redis Pub/Sub                                                    | Decouples systems for scalable events.                                                    | Use Google Pub/Sub API or Redis `PUBLISH`/`SUBSCRIBE` commands.                                      |
| **Global Coordination**            | Managing distributed system state.                                               |                                                                                  |                                                                                           |                                                                                                     |
| Consensus Algorithm                | Agreement on state across nodes.                                                 | Paxos, Raft                                                                      | Leader election, state machines (e.g., Spanner).                                          | Use Raft in etcd or Consul; implement Paxos in custom systems.                                       |
| Distributed Locking                | Ensures exclusive access in distributed systems.                                 | Zookeeper, Redis                                                                 | Prevents conflicts (e.g., Redis locks).                                                  | Use Zookeeper’s locks or Redis `SETNX` for atomic locking.                                           |
| CAP Theorem                        | Tradeoff framework: Consistency, Availability, Partition Tolerance.              | Understand tradeoffs                                                             | Guides design (e.g., CP for banking, AP for social).                                      | Analyze with tools like Jepsen for testing distributed system behavior.                              |
| **Other Techniques**               | Miscellaneous system design tools.                                               |                                                                                  |                                                                                           |                                                                                                     |
| Consistent Hashing                 | Distributes data with minimal reshuffling.                                       | Redis Cluster, DynamoDB                                                          | Minimizes movement (e.g., CDNs, caching).                                                 | Implement with hash rings in Redis Cluster or DynamoDB partitioning.                                 |
| Rate Limiting                      | Controls request frequency.                                                      | Token Bucket, Leaky Bucket                                                       | Prevents abuse, ensures fairness (e.g., APIs).                                            | Use Redis with Lua scripts for Token Bucket or Nginx rate limiting module.                           |
| Fault Tolerance                    | System resilience to failures.                                                   | Replication, Failover                                                            | High availability (e.g., YouTube metadata).                                               | Replicate with DB tools (e.g., MySQL replication); failover with HAProxy.                            |
| Circuit Breaker                    | Stops requests to failing services.                                              | Hystrix, Resilience4j                                                            | Prevents cascading failures (e.g., microservices).                                        | Integrate Resilience4j in app code or use Hystrix with Spring Boot.                                  |
| **Architectural Patterns**         | High-level system structures.                                                    |                                                                                  |                                                                                           |                                                                                                     |
| Microservices                      | Independent, small services.                                                     | REST/gRPC, Docker, Kubernetes                                                    | Scalability, independent deployment (e.g., Netflix).                                      | Containerize with Docker; orchestrate with Kubernetes; communicate via REST/gRPC.                    |
| Serverless                         | Event-driven, no server management.                                              | AWS Lambda, Google Cloud Functions                                               | Cost-effective, sporadic workloads, no ops overhead.                                      | Deploy functions with AWS Lambda; trigger via events (e.g., S3, SNS).                                |
| Event-Driven                       | Systems react to events, not requests.                                           | Kafka, RabbitMQ                                                                  | Real-time, decoupled (e.g., Uber, DoorDash).                                              | Use Kafka for event streams or RabbitMQ for queues; process with consumers.                          |
| **System Design Building Blocks**  | Core components of distributed systems.                                          |                                                                                  |                                                                                           |                                                                                                     |
| APIs                               | Interfaces for system communication.                                             | REST, gRPC                                                                       | REST for simplicity, gRPC for performance.                                                | Build REST with Flask/FastAPI; gRPC with Protocol Buffers and gRPC tools.                            |
| Content Delivery Network (CDN)     | Distributed network for static content.                                          | Cloudflare, Akamai                                                               | Reduces latency, caches globally.                                                         | Configure Cloudflare/Akamai with origin server; cache static assets.                                 |
| Proxy vs Reverse Proxy             | Proxy forwards client requests; reverse proxy balances server load.              | Nginx, HAProxy                                                                   | Proxy for clients, reverse proxy for servers.                                             | Use Nginx as reverse proxy with upstream servers; proxy with client-side configs.                    |
| Domain Name System (DNS)           | Translates domains to IPs.                                                       | AWS Route 53, Cloudflare DNS                                                     | High availability, low-latency resolution.                                                | Set up Route 53 with health checks or Cloudflare with geo-routing.                                   |
| API Gateway                        | Manages API traffic and policies.                                                | Kong, AWS API Gateway                                                            | Handles auth, rate limiting, routing.                                                     | Deploy Kong with plugins or AWS API Gateway with Lambda integration.                                 |
| **Tradeoffs**                      | Choices with pros/cons to balance.                                               |                                                                                  |                                                                                           | **Tool for Tradeoff Analysis**                                                                      |
| Vertical vs Horizontal Scaling     | Vertical upgrades one machine; Horizontal adds machines.                         | Vertical for power, Horizontal for distribution                                  | Vertical is simpler, Horizontal scales better.                                            | Use benchmarking tools (e.g., JMeter, Locust) to test capacity limits.                               |
| Concurrency vs Parallelism         | Concurrency manages tasks; Parallelism runs them simultaneously.                 | Concurrency for multitasking, Parallelism for speed                              | Concurrency for responsiveness, Parallelism for throughput.                               | Profile with `perf` (Linux) or `ThreadPoolExecutor` (Python) to measure efficiency.                  |
| Long Polling vs WebSockets         | Long Polling uses HTTP waits; WebSockets are persistent.                         | Long Polling for compatibility, WebSockets for real-time                         | Long Polling for legacy, WebSockets for efficiency.                                       | Test latency with tools like Postman (Long Polling) vs WebSocket clients (e.g., `ws`).               |
| Batch vs Stream Processing         | Batch processes chunks; Stream handles real-time.                                | Batch for datasets, Stream for real-time                                         | Batch for analytics, Stream for immediacy.                                                | Compare with Apache Spark (batch) vs Kafka Streams (stream) for throughput/latency.                  |
| Stateful vs Stateless Design       | Stateful tracks state; Stateless doesn’t.                                        | Stateful for sessions, Stateless for scalability                                 | Stateful for simplicity, Stateless for scale.                                             | Simulate with Redis (stateful) vs REST APIs (stateless) using load tests (e.g., Locust).             |
| Strong vs Eventual Consistency     | Strong ensures immediate sync; Eventual allows delays.                           | Strong for transactions, Eventual for scalability                                | Strong for accuracy, Eventual for performance.                                            | Test with Jepsen or Chaos Monkey to verify consistency under failures.                               |
| **System Design Problems**         | Common design challenges.                                                        |                                                                                  |                                                                                           |                                                                                                     |
| URL Shortener                      | Shortens long URLs with unique IDs.                                              | Consistent Hashing, Redis, SQL/NoSQL                                             | Redis for lookups, SQL/NoSQL for scale/analytics.                                         | Use Redis for key-value store; shard with consistent hashing; SQL for stats (e.g., PostgreSQL).       |
| Distributed Cache                  | Cache spread across nodes.                                                       | Redis, Memcached                                                                 | Fast access in distributed systems.                                                       | Deploy Redis Cluster; use client libraries (e.g., `redis-py`) with sharding.                         |
| Notification Service               | Sends real-time alerts to users.                                                 | Kafka, Redis, WebSockets                                                         | Kafka for streaming, WebSockets for delivery.                                             | Kafka for event queue, Redis for caching, WebSockets for client push (e.g., `Socket.IO`).            |
| Rate Limiter                       | Limits request rates per user/system.                                            | Token Bucket, Redis                                                              | Redis for counts, Token Bucket for fairness.                                              | Implement Token Bucket with Redis Lua scripts; track rates per IP/key.                               |
| Distributed Locking                | Ensures exclusive access across nodes.                                           | Zookeeper, Redis                                                                 | Mutual exclusion in distributed systems.                                                  | Use Zookeeper’s lock recipes or Redis `SETNX` with expiration.                                       |
| Chat System                        | Real-time messaging platform.                                                    | WebSockets, Redis Pub/Sub, Cassandra                                             | WebSockets for chat, Cassandra for storage.                                               | WebSockets for messaging, Redis Pub/Sub for channels, Cassandra for persistence.                     |
| **Advanced Topics**                | Complex system design concepts.                                                  |                                                                                  |                                                                                           |                                                                                                     |
| Distributed Tracing                | Tracks requests across services.                                                 | Jaeger, Zipkin                                                                   | Debugs microservices performance.                                                         | Integrate Jaeger/Zipkin with app (e.g., OpenTelemetry); visualize traces.                            |
| Disaster Recovery                  | Restores system after failures.                                                  | Backups, Replication, Failover                                                   | Ensures data/system availability.                                                         | Use AWS S3 for backups, MySQL replication, HAProxy for failover.                                     |
| Distributed Web Crawler            | Crawls web in parallel across nodes.                                             | Kafka, Redis, Bloom Filters                                                      | Kafka for tasks, Bloom for deduplication.                                                 | Kafka for job queue, Redis for coordination, Bloom Filters in-memory for URL checks.                 |
| Distributed Cloud Storage          | Scalable, fault-tolerant file storage.                                           | Consistent Hashing, Replication, Sharding                                        | Scalability, resilience (e.g., S3).                                                       | Use consistent hashing for partitioning; replicate with tools like Hadoop HDFS.                     |
| Bloom Filters                      | Probabilistic set membership test.                                               | Redis Bloom, custom implementation                                               | Space-efficient deduplication/caching.                                                    | Add Redis Bloom module or implement in code (e.g., Python `pybloomfiltermmap`).                      |

---
