### **System Design Interview Questions Cheat Sheet**

| **Question**                       | **What It Tests**                                                                 | **Key Steps to Solve**                                                                                     | **Considerations**                                                                                   | **Tools/Techniques**                                                                                  | **Vocabulary to Use**                                                                                   | **How to Handle (Interview Tips)**                                                                                     |
|------------------------------------|-----------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| **URL Shortener**                  | Scalability, key generation, persistence                                          | 1. Define requirements (e.g., 100M URLs/day).<br>2. Generate unique short IDs (base62 encoding).<br>3. Store mappings (key-value store).<br>4. Handle redirects (HTTP 301).<br>5. Scale with sharding. | Read/write ratio, collision risk, analytics needs.                                                   | Consistent Hashing, Redis (cache), DynamoDB (persistent store), Nginx (redirects).                     | Idempotency, sharding, eventual consistency, throughput                                                 | Start with a simple key-value store; scale with hashing for writes; discuss analytics tradeoffs (SQL vs. NoSQL).         |
| **Design Twitter**                 | Real-time feeds, scalability, fanout                                              | 1. Model entities (users, tweets, follows).<br>2. Design feed generation (push vs. pull).<br>3. Store data (tweets, relationships).<br>4. Scale reads (caching) and writes (sharding).<br>5. Add real-time updates. | Latency for feeds, write amplification, follower scale.                                              | Redis (cache), Cassandra (tweets), Kafka (real-time), Graph DB (follows), Load Balancer (Nginx).       | Fanout, quorum, latency, denormalization                                                                | Discuss push (fanout-on-write) vs. pull (on-read); justify caching for hot users; mention eventual consistency for feeds.|
| **Messaging System (WhatsApp)**    | Real-time messaging, reliability, storage                                         | 1. Define message flow (send, receive, ACK).<br>2. Enable real-time delivery (WebSockets).<br>3. Store messages (persistent DB).<br>4. Ensure delivery (queues).<br>5. Scale with partitioning. | Message durability, offline support, encryption.                                                     | WebSockets (real-time), Kafka (queue), Cassandra (storage), Redis (session), E2E Encryption (TLS).     | Ephemeral, ACK, partitioning, idempotent                                                        | Highlight WebSockets for low latency; discuss Kafka for reliability; address encryption and offline message handling.    |
| **Notification System**            | Event-driven delivery, scalability                                                | 1. Capture events (e.g., user actions).<br>2. Queue events (streaming).<br>3. Deliver via channels (push, email).<br>4. Scale with pub/sub.<br>5. Handle failures (retries). | Delivery latency, channel diversity, retry logic.                                                    | Kafka (event stream), Redis (cache), WebSockets (push), AWS SNS (multi-channel), Retry Queues.         | Pub/sub, backpressure, retry semantics, decoupling                                              | Emphasize decoupling with Kafka; discuss WebSockets vs. SNS for push; address retry with exponential backoff.           |
| **Distributed File Storage (Dropbox)** | File sync, scalability, availability                                           | 1. Chunk files for upload/download.<br>2. Store metadata (DB) and files (object store).<br>3. Sync changes (delta updates).<br>4. Ensure availability (replication).<br>5. Scale with sharding. | Bandwidth usage, consistency, versioning.                                                            | S3 (files), DynamoDB (metadata), Consistent Hashing (sharding), Replication (multi-region).             | Chunking, delta sync, replication, eventual consistency                                         | Start with S3 for simplicity; add sharding for scale; discuss delta sync for efficiency and replication for durability. |
| **Rate Limiter**                   | Traffic control, fairness                                                         | 1. Define limits (e.g., 100 reqs/min per IP).<br>2. Choose algorithm (Token Bucket).<br>3. Track usage (in-memory store).<br>4. Enforce limits (API Gateway).<br>5. Distribute across nodes. | Burst handling, distributed enforcement, fairness.                                                   | Redis (counter), Token Bucket (algorithm), AWS API Gateway (enforcement), Nginx (fallback).            | Throttling, burst capacity, distributed coordination                                            | Explain Token Bucket vs. Leaky Bucket; use Redis for speed; discuss distributed consistency with Redis Cluster.         |
| **Design YouTube**                 | Video streaming, scalability, metadata                                            | 1. Upload videos (chunked).<br>2. Store videos (object store) and metadata (DB).<br>3. Stream with CDN.<br>4. Scale metadata (sharding).<br>5. Recommend content (analytics). | Latency, storage cost, recommendation accuracy.                                                      | S3 (videos), Cassandra (metadata), Cloudflare (CDN), Kafka (events), Spark (recommendations).           | Transcoding, edge caching, sharding, telemetry                                                  | Focus on CDN for streaming; shard metadata for scale; mention Kafka for real-time views and Spark for recommendations.  |
| **E-commerce System (Amazon)**     | Transactions, inventory, scalability                                              | 1. Model entities (products, orders, users).<br>2. Ensure transactions (ACID DB).<br>3. Cache hot items.<br>4. Scale inventory (sharding).<br>5. Add search (indexing). | Consistency for orders, inventory updates, search latency.                                           | PostgreSQL (transactions), Redis (cache), Elasticsearch (search), Kafka (events), Sharding.            | ACID, cache coherence, indexing, eventual consistency                                           | Prioritize ACID for orders; use Redis for caching; discuss Elasticsearch for search and Kafka for order events.         |
| **Ride-Sharing (Uber)**            | Real-time tracking, matching, scalability                                         | 1. Track drivers/riders (geo-data).<br>2. Match requests (algorithm).<br>3. Update in real-time (WebSockets).<br>4. Store trips (DB).<br>5. Scale with partitioning. | Latency for matching, geo-queries, reliability.                                                      | WebSockets (real-time), Redis (geo-cache), Cassandra (trips), Kafka (events), Geohashing.              | Geospatial, matching latency, event sourcing                                                    | Highlight WebSockets for tracking; use geohashing for matching; discuss Kafka for event-driven updates.                 |
| **Search Engine (Google)**         | Indexing, ranking, scalability                                                    | 1. Crawl web (distributed crawler).<br>2. Index data (inverted index).<br>3. Rank results (algorithm).<br>4. Cache queries.<br>5. Scale with sharding. | Crawl efficiency, index size, query latency.                                                         | Kafka (crawler queue), Elasticsearch (index), Redis (cache), Consistent Hashing (sharding).            | Inverted index, ranking, sharding, query latency                                                | Start with crawling (Kafka); explain indexing (Elasticsearch); discuss caching and sharding for scale.                 |
| **Distributed Key-Value Store**    | Scalable, low-latency data storage                                                | 1. Define ops (get, put, delete).<br>2. Distribute data (hashing).<br>3. Replicate for fault tolerance.<br>4. Ensure consistency (quorum).<br>5. Scale with nodes. | Consistency model, latency, partition tolerance.                                                     | DynamoDB (managed), Redis Cluster (in-memory), Consistent Hashing, Raft (consensus).                   | Quorum, replication, partition tolerance, latency                                               | Discuss Dynamo-style design; explain quorum for consistency; scale with consistent hashing and Raft.                   |
| **Live Streaming (Twitch)**        | Real-time video delivery, scalability                                             | 1. Ingest streams (RTMP).<br>2. Transcode videos (multiple resolutions).<br>3. Deliver via CDN.<br>4. Store VODs (object store).<br>5. Scale ingest nodes. | Latency, bandwidth, viewer scale.                                                            | Nginx-RTMP (ingest), FFmpeg (transcoding), Cloudflare (CDN), S3 (VODs), Load Balancer.                 | Ingest, transcoding, edge delivery, jitter                                                      | Focus on RTMP for ingest; transcoding for quality; CDN for scale; discuss jitter handling.                             |
| **Payment System (Stripe)**        | Secure transactions, reliability                                                  | 1. Process payments (API).<br>2. Ensure security (encryption).<br>3. Store transactions (ACID DB).<br>4. Handle failures (retries).<br>5. Scale with sharding. | Idempotency, security, consistency.                                                          | PostgreSQL (transactions), Kafka (events), TLS (security), Redis (idempotency), Sharding.              | Idempotency, ACID compliance, retry semantics                                                   | Emphasize ACID for consistency; TLS for security; Kafka for event logging; Redis for idempotent retries.                |
| **Chatbot System**                 | Real-time NLP, scalability                                                        | 1. Process input (NLP).<br>2. Deliver responses (WebSockets).<br>3. Store history (DB).<br>4. Scale inference (serverless).<br>5. Cache responses. | Latency for NLP, conversation scale, history size.                                                   | WebSockets (real-time), AWS Lambda (NLP), DynamoDB (history), Redis (cache).                           | Inference, real-time, caching, stateless                                                        | Use WebSockets for chat; Lambda for NLP scale; DynamoDB for history; cache frequent responses.                         |
| **Social Media Analytics**         | Aggregating, analyzing large-scale data                                           | 1. Collect events (stream).<br>2. Aggregate data (batch/stream).<br>3. Store results (DB).<br>4. Query analytics (index).<br>5. Scale processing. | Data volume, query latency, freshness.                                                       | Kafka (stream), Spark (processing), Elasticsearch (query), Cassandra (storage).                        | Aggregation, batch processing, indexing, telemetry                                              | Start with Kafka for events; Spark for analytics; Elasticsearch for queries; scale with partitioning.                   |

---

### How to Use This Cheat Sheet
1. **Structured Approach**: Follow the "Key Steps to Solve" to break down any question methodically—interviewers love seeing a clear thought process.
   - Example: For "Design Twitter," start with entities, then feeds, then scaling—don’t jump to tools immediately.
2. **Considerations**: Highlight tradeoffs (e.g., latency vs. consistency) to show depth. Use these to justify your choices.
   - Example: "Push for low latency, but pull scales better for millions of followers."
3. **Tools/Techniques**: Map tools to requirements (e.g., Kafka for streams, Redis for cache) and explain why they fit.
   - Example: "Cassandra for YouTube metadata because it handles high write throughput."
4. **Vocabulary**: Sprinkle terms like "fanout," "quorum," or "idempotency" naturally to sound polished and precise.
   - Example: "We use quorum-based replication to ensure fault tolerance in the key-value store."
5. **Interview Tips**: Tailor your response to the interviewer’s focus (e.g., scalability, reliability) and pivot as needed.
   - Example: If they ask about failures, pivot to retries and circuit breakers.

---

### General Strategy for System Design Questions
1. **Clarify Requirements**: Ask about scale (e.g., "10M users/day?"), latency (e.g., "<100ms?"), and constraints (e.g., "cost-sensitive?").
   - Vocabulary: "Throughput," "latency SLA," "QPS (queries per second)."
2. **High-Level Design**: Sketch components (e.g., API, DB, cache) and data flow on a whiteboard or verbally.
   - Vocabulary: "Decoupling," "data plane," "control plane."
3. **Deep Dive**: Pick 1-2 critical areas (e.g., scaling, fault tolerance) and elaborate with tools and tradeoffs.
   - Vocabulary: "Sharding," "replication factor," "backpressure."
4. **Scale It**: Discuss horizontal scaling, sharding, or caching to handle growth.
   - Vocabulary: "Partition tolerance," "load shedding," "elasticity."
5. **Handle Failures**: Address failures (e.g., retries, replication) and edge cases (e.g., offline users).
   - Vocabulary: "Fault isolation," "circuit breaking," "eventual consistency."
6. **Optimize**: Suggest improvements (e.g., CDN, compression) and justify with metrics.
   - Vocabulary: "Telemetry," "optimization," "jitter buffer."

---

### Advanced Additions
- **Cross-Cutting Concerns**: For every design, consider:
  - **Security**: TLS, OAuth2, zero-trust (e.g., "Encrypt payment data with TLS").
  - **Observability**: Tracing (Jaeger), metrics (Prometheus) (e.g., "Trace latency with Jaeger").
  - **Resilience**: Chaos engineering, circuit breakers (e.g., "Test with Chaos Monkey").
- **Vocabulary Boost**: Use "telemetry" (monitoring), "idempotency" (repeatable ops), "quorum" (agreement), "jitter" (latency variance).
- **Interview Flex**: Be ready to pivot—e.g., if asked "How does this handle 1B users?" scale up with sharding and CDNs.

---

### Example Walkthrough: "Design Twitter"
- **Requirements**: 100M tweets/day, real-time feeds, 500M users.
- **Steps**: 
  1. Entities: Users, tweets, follows (Graph DB or Cassandra).
  2. Feeds: Push for active users (Kafka fanout), pull for others (Redis cache).
  3. Storage: Cassandra for tweets, Redis for hot data.
  4. Scale: Shard Cassandra by user ID, load balance with Nginx.
  5. Real-time: WebSockets for updates.
- **Considerations**: Fanout latency vs. storage cost; consistency for follows.
- **Tools**: Kafka (events), Redis (cache), Cassandra (storage), WebSockets (live).
- **Vocabulary**: "Fanout-on-write," "event sourcing," "denormalized reads."
- **Tip**: Start simple, then scale—e.g., "For 1M users, Redis suffices; for 500M, we shard Cassandra."

---
