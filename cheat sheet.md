
## Table of Contents
1. [Protocols](#protocols)
2. [Server Software/Services](#server-software-services)
3. [Databases](#databases)
4. [Caching](#caching)
5. [Scaling](#scaling)
6. [Messaging & Queues](#messaging--queues)
7. [Global Coordination](#global-coordination)
8. [Other Techniques](#other-techniques)
9. [Architectural Patterns](#architectural-patterns)
10. [System Design Building Blocks](#system-design-building-blocks)
11. [Tradeoffs](#tradeoffs)
12. [System Design Problems](#system-design-problems)
13. [Advanced Topics](#advanced-topics)

---

## Protocols

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| HTTP/HTTPS                         | Stateless protocol for web requests; HTTPS adds TLS encryption.                  | REST APIs, Web Services                                                          | Ubiquitous, interoperable, ideal for client-server.                                       | Use Flask/FastAPI with TLS (e.g., Certbot for HTTPS).                                                | HTTP lacks multiplexing (HTTP/2 fixes this); HTTPS ensures confidentiality vs. HTTPâ€™s plaintext vulnerability.         |
| HTTP/2                             | Evolution of HTTP with binary framing and multiplexing.                          | High-performance APIs                                                            | Reduces latency via multiplexing, header compression.                                     | Deploy with Nginx (HTTP/2 module) or gRPC over HTTP/2.                                               | HTTP/2 vs. HTTP: Binary vs. text, supports push; vs. gRPC: General-purpose vs. RPC-focused.                           |
| gRPC                               | High-performance RPC using HTTP/2 and Protocol Buffers.                          | Microservices, RPC                                                               | Low-latency, strongly-typed, supports streaming.                                          | Use gRPC-Go with Protobuf; integrate with Kubernetes.                                                | gRPC vs. REST: Binary vs. JSON, bidirectional streaming vs. request-response; vs. HTTP/2: RPC layer vs. transport.     |
| WebSockets                         | Persistent, bidirectional connection over TCP.                                   | Real-time apps (chat, gaming)                                                    | Full-duplex, low overhead for live updates.                                               | Implement with `Socket.IO` or `ws` (Node.js); scale with Redis Pub/Sub.                              | WebSockets vs. HTTP: Stateful vs. stateless; vs. Long Polling: Persistent vs. repeated requests.                       |
| MQTT                               | Lightweight pub/sub protocol for resource-constrained devices.                   | IoT, telemetry                                                                   | Bandwidth-efficient, reliable over unstable networks.                                     | Use Mosquitto broker; connect with Paho MQTT client.                                                 | MQTT vs. AMQP: Simpler, less routing vs. robust queuing; vs. WebSockets: Lightweight vs. heavier TCP connection.        |
| AMQP                               | Advanced message queuing protocol with robust routing.                           | Reliable messaging (RabbitMQ)                                                    | Ensures delivery, supports complex routing (e.g., fanout).                                | Deploy RabbitMQ; configure exchanges with `pika` (Python).                                           | AMQP vs. MQTT: Richer features vs. lightweight; vs. Kafka: Queue-based vs. log-based streaming.                        |
| Kafka Protocol                     | Distributed log protocol for event streaming.                                    | High-throughput streaming                                                        | Durable, scalable, replayable event logs.                                                 | Use Kafka cluster with `confluent-kafka` (Python); ZooKeeper for coordination.                       | Kafka vs. AMQP: Log persistence vs. transient queues; vs. MQTT: High-throughput vs. low-bandwidth focus.                |
| GraphQL                            | Query language protocol for precise data fetching.                               | Flexible APIs (GitHub API)                                                       | Reduces over-fetching, client-driven queries.                                             | Use Apollo Server; define schemas with resolvers.                                                    | GraphQL vs. REST: Single endpoint vs. multiple; vs. gRPC: Flexible queries vs. strict contracts.                       |

---

## Server Software/Services

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| SMTP (via Mail Servers)            | Protocol for email, implemented by mail servers.                                 | Postfix, Sendmail                                                                | Standard for email transmission.                                                          | Configure Postfix with SMTP relay; use `nodemailer` for automation.                                  | SMTP vs. SNS: Email-specific vs. multi-channel notifications; Postfix vs. Sendmail: Config ease vs. legacy support.    |
| FTP/SFTP (via File Servers)        | Protocols for file transfer; SFTP uses SSH for security.                         | FileZilla Server, OpenSSH (SFTP)                                                 | FTP for simplicity, SFTP for encrypted transfers.                                         | Set up OpenSSH (SFTP) with key auth; use `scp` for transfers.                                        | FTP vs. SFTP: Insecure vs. secure; vs. NFS: Point-to-point vs. network-shared filesystem.                              |
| RTMP (via Streaming Servers)       | Real-time video streaming protocol via dedicated servers.                        | Nginx-RTMP, Wowza                                                                | Low-latency for live broadcasts (Twitch).                                                 | Configure Nginx-RTMP; stream via OBS with RTMP URL.                                                  | RTMP vs. WebSockets: Video-focused vs. general-purpose; Nginx-RTMP vs. Wowza: Open-source vs. commercial features.      |
| SNS                                | Managed service for multi-channel notifications.                                 | AWS SNS                                                                          | Scalable push notifications (SMS, mobile).                                                | Use AWS SDK (boto3) with SNS topics; integrate with Lambda.                                          | SNS vs. SMTP: Multi-platform vs. email-only; vs. Kafka: Managed simplicity vs. self-hosted streaming.                  |
| NFS                                | Distributed filesystem for shared storage.                                       | NFS Server (Linux)                                                               | Enables multi-server file access.                                                         | Deploy `nfs-kernel-server` on Linux; mount with `mount -t nfs`.                                      | NFS vs. FTP: Shared access vs. one-off transfers; vs. S3: Local network vs. cloud-based.                               |

---

## Databases

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Relational (SQL)                   | Tabular, schema-enforced data with ACID properties.                              | PostgreSQL, MySQL                                                                | Strong consistency, transactional integrity.                                              | Use RDS or local install; query with SQLAlchemy (Python).                                            | SQL vs. NoSQL: Structured vs. flexible; PostgreSQL vs. MySQL: Advanced features vs. simplicity.                        |
| NoSQL (Key-Value)                  | Simple key-value pairs, often in-memory.                                         | Redis, DynamoDB                                                                  | High-speed lookups, caching.                                                              | Deploy Redis locally; use DynamoDB via AWS SDK.                                                      | Redis vs. DynamoDB: In-memory vs. persistent; vs. Document: Flat vs. nested data.                                      |
| NoSQL (Document)                   | JSON-like documents with flexible schemas.                                       | MongoDB, CouchDB                                                                 | Hierarchical data, schema evolution (CMS).                                                | Use MongoDB Atlas; query with PyMongo.                                                               | Document vs. Key-Value: Nested vs. flat; MongoDB vs. CouchDB: Scale vs. sync features.                                 |
| NoSQL (Columnar)                   | Wide-column store optimized for analytics.                                       | Apache Cassandra, Bigtable                                                       | Scalable writes, time-series (recommendations).                                           | Deploy Cassandra cluster; use CQL with `cassandra-driver`.                                           | Columnar vs. Document: Analytics vs. flexibility; Cassandra vs. Bigtable: Open-source vs. managed.                      |
| NoSQL (Graph)                      | Node-edge model for relationship-heavy data.                                     | Neo4j, ArangoDB                                                                  | Complex queries (social networks, fraud).                                                 | Run Neo4j; query with Cypher via `neo4j-driver`.                                                     | Graph vs. Relational: Relationships vs. tables; Neo4j vs. ArangoDB: Dedicated vs. multi-model.                         |
| Time-Series                        | Optimized for sequential, timestamped data.                                      | InfluxDB, TimescaleDB                                                            | Efficient for IoT, monitoring metrics.                                                    | Deploy InfluxDB; use `influxdb-client-python`.                                                       | Time-Series vs. Columnar: Time-optimized vs. general analytics; InfluxDB vs. TimescaleDB: Native vs. SQL extension.     |

---

## Caching

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Cache-aside                        | App-managed cache with lazy loading.                                             | Redis, Memcached                                                                 | Reduces DB load, flexible control.                                                        | Use `redis-py`; app checks cache, fetches on miss.                                                   | Cache-aside vs. Write-through: Manual vs. auto-sync; Redis vs. Memcached: Features vs. simplicity.                     |
| Write-through                      | Synchronous cache and DB updates.                                                | Redis                                                                            | Cache-DB consistency for read-heavy loads.                                                | Implement with Redis; update both in app logic.                                                      | Write-through vs. Write-behind: Immediate vs. delayed sync; vs. Read-through: Write vs. read focus.                    |
| Write-behind                       | Asynchronous DB sync after cache write.                                          | Redis                                                                            | Reduces write latency, eventual consistency.                                              | Use Redis with Celery for async DB writes.                                                           | Write-behind vs. Write-through: Latency vs. consistency; vs. Cache-aside: Auto vs. manual fetch.                       |
| Read-through                       | Cache auto-fetches DB on miss.                                                   | CDN, API Gateway                                                                 | Simplifies app logic (e.g., CDN caching).                                                 | Configure AWS API Gateway cache or Cloudflare CDN.                                                   | Read-through vs. Cache-aside: Auto vs. manual; CDN vs. Redis: Edge vs. in-memory.                                      |
| Distributed Cache                  | Cache spanning multiple nodes with coherence.                                    | Hazelcast, Redis Cluster                                                         | Scales for high availability/performance.                                                 | Deploy Redis Cluster; use consistent hashing.                                                        | Distributed vs. Local: Scalability vs. simplicity; Hazelcast vs. Redis: Java-native vs. broader support.               |
| Eviction Strategy                  | Policies for removing stale cache entries.                                       | LRU, LFU, TTL                                                                    | Balances memory use (LRU: recent, LFU: frequent).                                         | Set Redis `maxmemory-policy` (e.g., `allkeys-lru`).                                                  | LRU vs. LFU: Recency vs. frequency; vs. TTL: Usage-based vs. time-based expiration.                                    |

---

## Scaling

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Horizontal Scaling                 | Adds more nodes to distribute workload.                                          | Microservices, Sharding                                                          | Infinite scale (e.g., Twitter).                                                           | Use Kubernetes for microservices; shard with Vitess.                                                 | Horizontal vs. Vertical: Distributed vs. single-node; vs. Sharding: App vs. DB focus.                                  |
| Vertical Scaling                   | Increases power of a single machine.                                             | Single powerful machine                                                          | Simpler for compute/memory-bound tasks.                                                   | Upgrade AWS EC2 instance (e.g., t3.large â†’ t3.2xlarge).                                              | Vertical vs. Horizontal: Ease vs. scalability; vs. Load Balancing: Hardware vs. traffic distribution.                  |
| Load Balancing                     | Distributes traffic across servers.                                              | Nginx, HAProxy                                                                   | Enhances reliability, evens load.                                                         | Configure Nginx with round-robin or least-connection.                                                | Load Balancing vs. Sharding: Traffic vs. data split; Nginx vs. HAProxy: Ease vs. advanced routing.                     |
| Database Sharding                  | Partitions DB across servers by key.                                             | Vitess (MySQL), Citus (PostgreSQL)                                               | Scales writes for massive datasets.                                                       | Use Vitess for MySQL; define shard keys in app logic.                                                | Sharding vs. Replication: Write scale vs. read scale; Vitess vs. Citus: MySQL vs. PostgreSQL ecosystem.                |

---

## Messaging & Queues

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Message Queue                      | Buffers tasks/messages for processing.                                           | Kafka, RabbitMQ                                                                  | Kafka: durable streams; RabbitMQ: reliable queues.                                        | Deploy Kafka with `confluent-kafka`; RabbitMQ with `pika`.                                           | Kafka vs. RabbitMQ: Log vs. queue; vs. Pub/Sub: Ordered vs. broadcast delivery.                                        |
| Event-Driven Architecture          | Systems triggered by events, not requests.                                       | Kafka, AWS Lambda                                                                | Decoupled, real-time (e.g., Uber).                                                        | Use Kafka topics with Lambda triggers; process with consumers.                                       | Event-Driven vs. Queue: Reactive vs. buffered; Kafka vs. Lambda: Persistent vs. ephemeral compute.                      |
| Pub/Sub                            | Broadcasts messages to multiple subscribers.                                     | Google Pub/Sub, Redis Pub/Sub                                                    | Scalable, decoupled event distribution.                                                   | Use Google Pub/Sub API or Redis `PUBLISH`/`SUBSCRIBE`.                                               | Pub/Sub vs. Queue: Many-to-many vs. one-to-one; Google vs. Redis: Managed vs. lightweight.                             |

---

## Global Coordination

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Consensus Algorithm                | Achieves agreement on state across nodes.                                        | Paxos, Raft                                                                      | Reliable leader election (e.g., etcd).                                                    | Use Raft in Consul; implement Paxos for custom systems.                                              | Paxos vs. Raft: Complexity vs. readability; vs. Locking: State vs. access control.                                     |
| Distributed Locking                | Ensures exclusive resource access across nodes.                                  | Zookeeper, Redis                                                                 | Prevents race conditions (e.g., Redis locks).                                             | Use Zookeeper locks or Redis `SETNX` with expiry.                                                    | Locking vs. Consensus: Access vs. state; Zookeeper vs. Redis: Robust vs. lightweight.                                  |
| CAP Theorem                        | Framework balancing Consistency, Availability, Partition Tolerance.              | Understand tradeoffs                                                             | Guides design (CP: banking, AP: social).                                                  | Test with Jepsen for consistency under partitions.                                                   | CAP vs. ACID: Distributed vs. single-node; CP vs. AP: Accuracy vs. uptime tradeoffs.                                   |

---

## Other Techniques

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Consistent Hashing                 | Distributes data with minimal reshuffling.                                       | Redis Cluster, DynamoDB                                                          | Reduces remapping (e.g., CDNs).                                                           | Implement hash rings in Redis Cluster or DynamoDB.                                                   | Consistent vs. Simple Hashing: Minimal movement vs. full rehash; vs. Sharding: Dynamic vs. static split.               |
| Rate Limiting                      | Caps request frequency to prevent overload.                                      | Token Bucket, Leaky Bucket                                                       | Ensures fairness, prevents abuse (APIs).                                                  | Use Redis with Lua for Token Bucket; Nginx for Leaky Bucket.                                         | Token vs. Leaky Bucket: Burst allowance vs. steady rate; vs. Circuit Breaker: Prevention vs. failure response.          |
| Fault Tolerance                    | Maintains operation despite failures.                                            | Replication, Failover                                                            | High availability (e.g., YouTube).                                                        | Replicate with MySQL; failover with HAProxy.                                                         | Replication vs. Failover: Data vs. service continuity; vs. Circuit Breaker: Proactive vs. reactive resilience.          |
| Circuit Breaker                    | Halts requests to failing services.                                              | Hystrix, Resilience4j                                                            | Prevents cascading failures (microservices).                                              | Use Resilience4j in Spring Boot; monitor with metrics.                                               | Circuit Breaker vs. Rate Limiting: Failure vs. usage control; Hystrix vs. Resilience4j: Monolithic vs. lightweight.     |

---

## Architectural Patterns

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Microservices                      | Small, autonomous services communicating via APIs.                               | REST/gRPC, Docker, Kubernetes                                                    | Independent scaling, deployment (Netflix).                                                | Dockerize services; orchestrate with Kubernetes; use gRPC.                                           | Microservices vs. Monolith: Granularity vs. simplicity; vs. Serverless: Persistent vs. ephemeral.                      |
| Serverless                         | Event-driven compute without server management.                                  | AWS Lambda, Google Cloud Functions                                               | Cost-efficient, auto-scaling (sporadic loads).                                            | Deploy Lambda with S3 triggers; use API Gateway.                                                     | Serverless vs. Microservices: No ops vs. control; Lambda vs. GCF: AWS ecosystem vs. Google integration.                |
| Event-Driven                       | Systems reacting to asynchronous events.                                         | Kafka, RabbitMQ                                                                  | Decoupled, real-time (Uber).                                                              | Use Kafka for streams; process with consumer groups.                                                 | Event-Driven vs. Request-Driven: Async vs. sync; Kafka vs. RabbitMQ: Streams vs. queues.                               |

---

## System Design Building Blocks

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| APIs                               | Interfaces for programmatic interaction.                                         | REST, gRPC                                                                       | REST: simple, gRPC: performant.                                                           | Build REST with FastAPI; gRPC with Protobuf.                                                         | REST vs. gRPC: Human-readable vs. binary; vs. GraphQL: Fixed vs. flexible endpoints.                                   |
| Content Delivery Network (CDN)     | Edge servers caching static content globally.                                    | Cloudflare, Akamai                                                               | Lowers latency, offloads origin (e.g., Netflix).                                          | Configure Cloudflare with origin pull; cache static files.                                           | CDN vs. Reverse Proxy: Global vs. local; Cloudflare vs. Akamai: Ease vs. enterprise features.                          |
| Proxy vs Reverse Proxy             | Proxy forwards client requests; reverse proxy distributes to servers.            | Nginx, HAProxy                                                                   | Proxy: client-side, Reverse: server-side load balancing.                                  | Use Nginx as reverse proxy with upstreams; proxy via client configs.                                 | Proxy vs. Reverse: Outbound vs. inbound; Nginx vs. HAProxy: General vs. high-performance balancing.                     |
| Domain Name System (DNS)           | Resolves domain names to IP addresses.                                           | AWS Route 53, Cloudflare DNS                                                     | Fast, reliable name resolution.                                                           | Set Route 53 with geo-DNS; use Cloudflare for DDoS protection.                                       | DNS vs. CDN: Resolution vs. delivery; Route 53 vs. Cloudflare: AWS-native vs. security focus.                          |
| API Gateway                        | Centralized entry point for API management.                                      | Kong, AWS API Gateway                                                            | Handles auth, throttling, routing (e.g., microservices).                                  | Deploy Kong with plugins; use AWS Gateway with Lambda.                                               | Gateway vs. Reverse Proxy: API logic vs. traffic; Kong vs. AWS: Open-source vs. managed.                               |

---

## Tradeoffs

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Vertical vs Horizontal Scaling     | Vertical: bigger machine; Horizontal: more machines.                             | Vertical for power, Horizontal for distribution                                  | Vertical: simple, Horizontal: scalable.                                                   | Benchmark with JMeter; simulate with Kubernetes.                                                     | Vertical vs. Horizontal: Capex vs. opex; vs. Sharding: Hardware vs. data split.                                        |
| Concurrency vs Parallelism         | Concurrency: task switching; Parallelism: simultaneous execution.                | Concurrency for multitasking, Parallelism for speed                              | Concurrency: responsiveness, Parallelism: throughput.                                     | Profile with `perf` or `concurrent.futures` (Python).                                                | Concurrency vs. Parallelism: Logical vs. physical; vs. Async: Single-thread vs. multi-thread.                           |
| Long Polling vs WebSockets         | Long Polling: HTTP waits; WebSockets: persistent connection.                     | Long Polling for legacy, WebSockets for real-time                                | Long Polling: compatible, WebSockets: efficient.                                          | Test with Postman (Long Polling) vs. `ws` (WebSockets).                                              | Long Polling vs. WebSockets: Overhead vs. persistence; vs. Server-Sent Events: Client vs. server push.                 |
| Batch vs Stream Processing         | Batch: processes chunks; Stream: real-time flow.                                 | Batch for datasets, Stream for real-time                                         | Batch: analytics, Stream: immediacy.                                                      | Compare Spark (batch) vs. Kafka Streams (stream).                                                    | Batch vs. Stream: Latency vs. throughput; vs. Event-Driven: Scheduled vs. triggered.                                    |
| Stateful vs Stateless Design       | Stateful: retains context; Stateless: no memory.                                 | Stateful for sessions, Stateless for scalability                                 | Stateful: simple sessions, Stateless: scale.                                              | Simulate with Redis (stateful) vs. REST (stateless).                                                 | Stateful vs. Stateless: Complexity vs. resilience; vs. Serverless: Persistent vs. ephemeral.                            |
| Strong vs Eventual Consistency     | Strong: immediate sync; Eventual: delayed sync.                                  | Strong for transactions, Eventual for scalability                                | Strong: accuracy, Eventual: performance.                                                  | Test with Jepsen or Chaos Monkey for consistency.                                                    | Strong vs. Eventual: Latency vs. availability; vs. ACID: Distributed vs. local guarantees.                              |

---

## System Design Problems

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| URL Shortener                      | Maps long URLs to short IDs.                                                     | Consistent Hashing, Redis, SQL/NoSQL                                             | Redis: fast lookups, NoSQL: scale.                                                        | Use Redis for key store; shard with hash ring; SQL for analytics.                                    | URL Shortener vs. Cache: Persistence vs. ephemerality; SQL vs. NoSQL: Analytics vs. write scale.                        |
| Distributed Cache                  | Cache replicated across nodes.                                                   | Redis, Memcached                                                                 | Fast, distributed access.                                                                 | Deploy Redis Cluster; use `redis-py` with sharding.                                                  | Distributed vs. Local Cache: Scale vs. latency; Redis vs. Memcached: Persistence vs. speed.                             |
| Notification Service               | Delivers real-time alerts.                                                       | Kafka, Redis, WebSockets                                                         | Kafka: streams, WebSockets: delivery.                                                     | Kafka for queue, Redis for cache, WebSockets for push.                                               | Notification vs. Chat: One-way vs. two-way; Kafka vs. SNS: Self-hosted vs. managed.                                     |
| Rate Limiter                       | Restricts request frequency.                                                     | Token Bucket, Redis                                                              | Fairness, overload protection.                                                            | Use Redis Lua for Token Bucket; track per IP.                                                        | Rate Limiter vs. Circuit Breaker: Prevention vs. recovery; Token vs. Leaky: Burst vs. steady.                           |
| Distributed Locking                | Ensures mutual exclusion across nodes.                                           | Zookeeper, Redis                                                                 | Prevents conflicts in distributed systems.                                                | Use Zookeeper locks or Redis `SETNX`.                                                                | Locking vs. Consensus: Access vs. state; Zookeeper vs. Redis: Durability vs. speed.                                    |
| Chat System                        | Real-time bidirectional messaging.                                               | WebSockets, Redis Pub/Sub, Cassandra                                             | WebSockets: live chat, Cassandra: storage.                                                | WebSockets for messaging, Redis for channels, Cassandra for logs.                                    | Chat vs. Notification: Two-way vs. one-way; Cassandra vs. MongoDB: Scale vs. flexibility.                               |

---

## Advanced Topics

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **Key Differences (Interview Qs)**                                                                                     |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Distributed Tracing                | Tracks requests across microservices.                                            | Jaeger, Zipkin                                                                   | Debugs latency, dependencies.                                                             | Use OpenTelemetry with Jaeger; visualize traces.                                                     | Tracing vs. Logging: Flow vs. events; Jaeger vs. Zipkin: Deployment vs. ecosystem integration.                         |
| Disaster Recovery                  | Restores system post-failure.                                                    | Backups, Replication, Failover                                                   | Ensures continuity (e.g., outages).                                                       | Use S3 backups, MySQL replication, HAProxy failover.                                                 | DR vs. Fault Tolerance: Recovery vs. prevention; Replication vs. Backup: Live vs. offline.                              |
| Distributed Web Crawler            | Parallel web scraping across nodes.                                              | Kafka, Redis, Bloom Filters                                                      | Kafka: task queue, Bloom: deduplication.                                                  | Kafka for jobs, Redis for state, Bloom for uniqueness.                                               | Crawler vs. Storage: Processing vs. persistence; Bloom vs. HashSet: Space vs. accuracy.                                |
| Distributed Cloud Storage          | Scalable, redundant file storage.                                                | Consistent Hashing, Replication, Sharding                                        | Fault-tolerant scale (e.g., S3).                                                          | Use hash rings, replicate with HDFS, shard data.                                                     | Cloud vs. Local Storage: Accessibility vs. control; Sharding vs. Replication: Split vs. copy.                           |
| Bloom Filters                      | Probabilistic structure for set membership.                                      | Redis Bloom, custom implementation                                               | Space-efficient deduplication.                                                            | Use Redis Bloom module or `pybloomfiltermmap`.                                                       | Bloom vs. HashSet: Probabilistic vs. exact; vs. Cache: Membership vs. full data.                                        |
| Zero-Trust Architecture            | Security model assuming no implicit trust.                                       | Istio, OAuth2                                                                    | Mitigates insider threats, breaches.                                                      | Use Istio for service mesh; OAuth2 for auth.                                                         | Zero-Trust vs. Perimeter: Granular vs. boundary; Istio vs. OAuth: Network vs. identity.                                |
| Chaos Engineering                  | Intentionally injects failures to test resilience.                               | Chaos Monkey, Gremlin                                                            | Validates fault tolerance (e.g., Netflix).                                                | Deploy Chaos Monkey on AWS; script failure scenarios.                                                | Chaos vs. Fault Tolerance: Testing vs. design; Chaos Monkey vs. Gremlin: Open-source vs. commercial.                    |

---
