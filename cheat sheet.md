
## Table of Contents
1. [Protocols](#protocols)
2. [Server Software/Services](#server-software-services)
3. [Databases](#databases)
4. [Caching](#caching)
5. [Scaling](#scaling)
6. [Messaging & Queues](#messaging--queues)
7. [Global Coordination](#global-coordination)
8. [Other Techniques](#other-techniques)
9. [Architectural Patterns](#architectural-patterns)
10. [System Design Building Blocks](#system-design-building-blocks)
11. [Tradeoffs](#tradeoffs)
12. [Advanced Topics](#advanced-topics)

---

## Protocols

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| HTTP/HTTPS                         | Stateless protocol for web requests; HTTPS adds TLS encryption.                  | REST APIs, Web Services                                                          | Ubiquitous, interoperable, ideal for client-server.                                       | Use Flask/FastAPI with TLS (e.g., Certbot for HTTPS).                                                | General-purpose web communication.                                                                 | HTTP lacks multiplexing (HTTP/2 fixes this); HTTPS ensures confidentiality vs. HTTP’s plaintext vulnerability.         | Q: Why is HTTPS slower than HTTP? A: Due to TLS handshake overhead, but modern optimizations minimize this.             |
| HTTP/2                             | Evolution of HTTP with binary framing and multiplexing.                          | High-performance APIs                                                            | Reduces latency via multiplexing, header compression.                                     | Deploy with Nginx (HTTP/2 module) or gRPC over HTTP/2.                                               | Real-time APIs, high-performance web apps.                                                         | HTTP/2 vs. HTTP: Binary vs. text, supports push; vs. gRPC: General-purpose vs. RPC-focused.                           | Q: Can HTTP/2 work without HTTPS? A: Technically yes, but most browsers enforce HTTPS for HTTP/2.                      |
| gRPC                               | High-performance RPC using HTTP/2 and Protocol Buffers.                          | Microservices, RPC                                                               | Low-latency, strongly-typed, supports streaming.                                          | Use gRPC-Go with Protobuf; integrate with Kubernetes.                                                | Microservices, inter-service communication.                                                        | gRPC vs. REST: Binary vs. JSON, bidirectional streaming vs. request-response; vs. HTTP/2: RPC layer vs. transport.     | Q: Why use gRPC over REST? A: For low-latency, strongly-typed APIs with streaming support.                             |
| WebSockets                         | Persistent, bidirectional connection over TCP.                                   | Real-time apps (chat, gaming)                                                    | Full-duplex, low overhead for live updates.                                               | Implement with `Socket.IO` or `ws` (Node.js); scale with Redis Pub/Sub.                              | Real-time apps like chat, gaming, live updates.                                                    | WebSockets vs. HTTP: Stateful vs. stateless; vs. Long Polling: Persistent vs. repeated requests.                       | Q: How does WebSocket handle firewalls? A: It uses HTTP-compatible handshake to bypass firewall restrictions.          |
| MQTT (Message Queuing Telemetry Transport) | Lightweight pub/sub protocol for resource-constrained devices.                   | IoT, telemetry                                                                   | Bandwidth-efficient, reliable over unstable networks.                                     | Use Mosquitto broker; connect with Paho MQTT client.                                                 | IoT, low-bandwidth environments.                                                                   | MQTT vs. AMQP: Simpler, less routing vs. robust queuing; vs. WebSockets: Lightweight vs. heavier TCP connection.        | Q: Why is MQTT preferred for IoT? A: Due to its lightweight nature and ability to handle unreliable networks.           |
| AMQP (Advanced Message Queuing Protocol) | Advanced message queuing protocol with robust routing.                           | Reliable messaging (RabbitMQ)                                                    | Ensures delivery, supports complex routing (e.g., fanout).                                | Deploy RabbitMQ; configure exchanges with `pika` (Python).                                           | Reliable messaging in distributed systems.                                                         | AMQP vs. MQTT: Richer features vs. lightweight; vs. Kafka: Queue-based vs. log-based streaming.                        | Q: When to use AMQP over Kafka? A: When you need complex routing and guaranteed delivery, not just high throughput.     |
| Kafka Protocol                     | Distributed log protocol for event streaming.                                    | High-throughput streaming                                                        | Durable, scalable, replayable event logs.                                                 | Use Kafka cluster with `confluent-kafka` (Python); ZooKeeper for coordination.                       | Event streaming, log aggregation.                                                                  | Kafka vs. AMQP: Log persistence vs. transient queues; vs. MQTT: High-throughput vs. low-bandwidth focus.                | Q: Can Kafka replace a database? A: No, it’s for event streaming, not transactional data storage.                       |
| GraphQL                            | Query language protocol for precise data fetching.                               | Flexible APIs (GitHub API)                                                       | Reduces over-fetching, client-driven queries.                                             | Use Apollo Server; define schemas with resolvers.                                                    | APIs requiring flexible, client-specific queries.                                                   | GraphQL vs. REST: Single endpoint vs. multiple; vs. gRPC: Flexible queries vs. strict contracts.                       | Q: Why not use GraphQL for everything? A: It adds complexity and may not be needed for simple APIs.                     |

---

## Server Software/Services

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| SMTP (Simple Mail Transfer Protocol) | Protocol for email, implemented by mail servers.                                 | Postfix, Sendmail                                                                | Standard for email transmission.                                                          | Configure Postfix with SMTP relay; use `nodemailer` for automation.                                  | Email delivery systems.                                                                             | SMTP vs. SNS: Email-specific vs. multi-channel notifications; Postfix vs. Sendmail: Config ease vs. legacy support.    | Q: Why is SMTP still used despite newer protocols? A: It’s universally supported and reliable for email.               |
| FTP/SFTP (File Transfer Protocol/Secure FTP) | Protocols for file transfer; SFTP uses SSH for security.                         | FileZilla Server, OpenSSH (SFTP)                                                 | FTP for simplicity, SFTP for encrypted transfers.                                         | Set up OpenSSH (SFTP) with key auth; use `scp` for transfers.                                        | File transfers in secure environments.                                                             | FTP vs. SFTP: Insecure vs. secure; vs. NFS: Point-to-point vs. network-shared filesystem.                              | Q: Why use SFTP over FTP? A: SFTP encrypts data, making it secure for sensitive transfers.                             |
| RTMP (Real-Time Messaging Protocol) | Real-time video streaming protocol via dedicated servers.                        | Nginx-RTMP, Wowza                                                                | Low-latency for live broadcasts (Twitch).                                                 | Configure Nginx-RTMP; stream via OBS with RTMP URL.                                                  | Live video streaming.                                                                               | RTMP vs. WebSockets: Video-focused vs. general-purpose; Nginx-RTMP vs. Wowza: Open-source vs. commercial features.      | Q: Why is RTMP still used despite WebSockets? A: RTMP is optimized for low-latency video streaming.                    |
| SNS (Simple Notification Service)  | Managed service for multi-channel notifications.                                 | AWS SNS                                                                          | Scalable push notifications (SMS, mobile).                                                | Use AWS SDK (boto3) with SNS topics; integrate with Lambda.                                          | Multi-channel notifications (SMS, email, mobile).                                                 | SNS vs. SMTP: Multi-platform vs. email-only; vs. Kafka: Managed simplicity vs. self-hosted streaming.                  | Q: When to use SNS over Kafka? A: For simple, managed notifications without needing event streaming.                   |
| NFS (Network File System)          | Distributed filesystem for shared storage.                                       | NFS Server (Linux)                                                               | Enables multi-server file access.                                                         | Deploy `nfs-kernel-server` on Linux; mount with `mount -t nfs`.                                      | Shared file access in local networks.                                                              | NFS vs. FTP: Shared access vs. one-off transfers; vs. S3: Local network vs. cloud-based.                               | Q: Why use NFS over S3? A: For low-latency, local network file sharing.                                                |

---

## Databases

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Relational (SQL)                   | Tabular, schema-enforced data with ACID properties.                              | PostgreSQL, MySQL                                                                | Strong consistency, transactional integrity.                                              | Use RDS or local install; query with SQLAlchemy (Python).                                            | Structured data with complex queries (e.g., banking).                                               | SQL vs. NoSQL: Structured vs. flexible; PostgreSQL vs. MySQL: Advanced features vs. simplicity.                        | Q: Why use SQL over NoSQL? A: For ACID compliance and complex queries.                                                |
| NoSQL (Key-Value)                  | Simple key-value pairs, often in-memory.                                         | Redis, DynamoDB                                                                  | High-speed lookups, caching.                                                              | Deploy Redis locally; use DynamoDB via AWS SDK.                                                      | Caching, session storage.                                                                          | Redis vs. DynamoDB: In-memory vs. persistent; vs. Document: Flat vs. nested data.                                      | Q: Why use Redis over DynamoDB? A: For in-memory caching and lower latency.                                            |
| NoSQL (Document)                   | JSON-like documents with flexible schemas.                                       | MongoDB, CouchDB                                                                 | Hierarchical data, schema evolution (CMS).                                                | Use MongoDB Atlas; query with PyMongo.                                                               | Flexible schema, hierarchical data (e.g., CMS).                                                    | Document vs. Key-Value: Nested vs. flat; MongoDB vs. CouchDB: Scale vs. sync features.                                 | Q: Why use MongoDB over SQL? A: For schema flexibility and hierarchical data.                                          |
| NoSQL (Columnar)                   | Wide-column store optimized for analytics.                                       | Apache Cassandra, Bigtable                                                       | Scalable writes, time-series (recommendations).                                           | Deploy Cassandra cluster; use CQL with `cassandra-driver`.                                           | Time-series data, analytics.                                                                       | Columnar vs. Document: Analytics vs. flexibility; Cassandra vs. Bigtable: Open-source vs. managed.                      | Q: Why use Cassandra over MongoDB? A: For write-heavy, time-series workloads.                                          |
| NoSQL (Graph)                      | Node-edge model for relationship-heavy data.                                     | Neo4j, ArangoDB                                                                  | Complex queries (social networks, fraud).                                                 | Run Neo4j; query with Cypher via `neo4j-driver`.                                                     | Relationship-heavy data (e.g., social networks).                                                   | Graph vs. Relational: Relationships vs. tables; Neo4j vs. ArangoDB: Dedicated vs. multi-model.                         | Q: Why use Neo4j over SQL? A: For efficient traversal of complex relationships.                                        |
| Time-Series                        | Optimized for sequential, timestamped data.                                      | InfluxDB, TimescaleDB                                                            | Efficient for IoT, monitoring metrics.                                                    | Deploy InfluxDB; use `influxdb-client-python`.                                                       | IoT, monitoring, metrics.                                                                          | Time-Series vs. Columnar: Time-optimized vs. general analytics; InfluxDB vs. TimescaleDB: Native vs. SQL extension.     | Q: Why use InfluxDB over Cassandra? A: For native time-series optimizations.                                           |

---

## Caching

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Cache-aside                        | App-managed cache with lazy loading.                                             | Redis, Memcached                                                                 | Reduces DB load, flexible control.                                                        | Use `redis-py`; app checks cache, fetches on miss.                                                   | Read-heavy workloads with infrequent writes.                                                        | Cache-aside vs. Write-through: Manual vs. auto-sync; Redis vs. Memcached: Features vs. simplicity.                     | Q: Why use Cache-aside over Write-through? A: For better control over cache updates.                                   |
| Write-through                      | Synchronous cache and DB updates.                                                | Redis                                                                            | Cache-DB consistency for read-heavy loads.                                                | Implement with Redis; update both in app logic.                                                      | Systems requiring strong cache-DB consistency.                                                      | Write-through vs. Write-behind: Immediate vs. delayed sync; vs. Read-through: Write vs. read focus.                    | Q: Why use Write-through over Cache-aside? A: To ensure cache and DB are always in sync.                               |
| Write-behind                       | Asynchronous DB sync after cache write.                                          | Redis                                                                            | Reduces write latency, eventual consistency.                                              | Use Redis with Celery for async DB writes.                                                           | Write-heavy systems with eventual consistency.                                                      | Write-behind vs. Write-through: Latency vs. consistency; vs. Cache-aside: Auto vs. manual fetch.                       | Q: Why use Write-behind over Write-through? A: To reduce write latency at the cost of eventual consistency.            |
| Read-through                       | Cache auto-fetches DB on miss.                                                   | CDN, API Gateway                                                                 | Simplifies app logic (e.g., CDN caching).                                                 | Configure AWS API Gateway cache or Cloudflare CDN.                                                   | Systems with predictable data access patterns.                                                      | Read-through vs. Cache-aside: Auto vs. manual; CDN vs. Redis: Edge vs. in-memory.                                      | Q: Why use Read-through over Cache-aside? A: To simplify app logic by automating cache fetches.                        |
| Distributed Cache                  | Cache spanning multiple nodes with coherence.                                    | Hazelcast, Redis Cluster                                                         | Scales for high availability/performance.                                                 | Deploy Redis Cluster; use consistent hashing.                                                        | High-availability, distributed systems.                                                             | Distributed vs. Local: Scalability vs. simplicity; Hazelcast vs. Redis: Java-native vs. broader support.               | Q: Why use Redis Cluster over a single Redis instance? A: For horizontal scaling and fault tolerance.                  |
| Eviction Strategy                  | Policies for removing stale cache entries.                                       | LRU, LFU, TTL                                                                    | Balances memory use (LRU: recent, LFU: frequent).                                         | Set Redis `maxmemory-policy` (e.g., `allkeys-lru`).                                                  | Systems with limited cache memory.                                                                  | LRU vs. LFU: Recency vs. frequency; vs. TTL: Usage-based vs. time-based expiration.                                    | Q: Why use LRU over LFU? A: When recent data is more relevant than frequently accessed data.                           |

---

## Scaling

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Horizontal Scaling                 | Adds more nodes to distribute workload.                                          | Microservices, Sharding                                                          | Infinite scale (e.g., Twitter).                                                           | Use Kubernetes for microservices; shard with Vitess.                                                 | Systems requiring high scalability.                                                                 | Horizontal vs. Vertical: Distributed vs. single-node; vs. Sharding: App vs. DB focus.                                  | Q: Why use Horizontal Scaling over Vertical? A: For unlimited scalability and fault tolerance.                         |
| Vertical Scaling                   | Increases power of a single machine.                                             | Single powerful machine                                                          | Simpler for compute/memory-bound tasks.                                                   | Upgrade AWS EC2 instance (e.g., t3.large → t3.2xlarge).                                              | Systems with limited scaling needs.                                                                 | Vertical vs. Horizontal: Ease vs. scalability; vs. Load Balancing: Hardware vs. traffic distribution.                  | Q: Why use Vertical Scaling over Horizontal? A: For simplicity and lower operational overhead.                         |
| Load Balancing                     | Distributes traffic across servers.                                              | Nginx, HAProxy                                                                   | Enhances reliability, evens load.                                                         | Configure Nginx with round-robin or least-connection.                                                | High-traffic systems requiring reliability.                                                        | Load Balancing vs. Sharding: Traffic vs. data split; Nginx vs. HAProxy: Ease vs. advanced routing.                     | Q: Why use Nginx over HAProxy? A: For simpler configuration and broader community support.                             |
| Database Sharding                  | Partitions DB across servers by key.                                             | Vitess (MySQL), Citus (PostgreSQL)                                               | Scales writes for massive datasets.                                                       | Use Vitess for MySQL; define shard keys in app logic.                                                | Systems with massive write workloads.                                                              | Sharding vs. Replication: Write scale vs. read scale; Vitess vs. Citus: MySQL vs. PostgreSQL ecosystem.                | Q: Why use Sharding over Replication? A: To scale writes, not just reads.                                             |

---

## Messaging & Queues

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Message Queue                      | Buffers tasks/messages for processing.                                           | Kafka, RabbitMQ                                                                  | Kafka: durable streams; RabbitMQ: reliable queues.                                        | Deploy Kafka with `confluent-kafka`; RabbitMQ with `pika`.                                           | Asynchronous task processing.                                                                       | Kafka vs. RabbitMQ: Log vs. queue; vs. Pub/Sub: Ordered vs. broadcast delivery.                                        | Q: Why use Kafka over RabbitMQ? A: For durable, high-throughput event streaming.                                      |
| Event-Driven Architecture          | Systems triggered by events, not requests.                                       | Kafka, AWS Lambda                                                                | Decoupled, real-time (e.g., Uber).                                                        | Use Kafka topics with Lambda triggers; process with consumers.                                       | Real-time, decoupled systems.                                                                      | Event-Driven vs. Queue: Reactive vs. buffered; Kafka vs. Lambda: Persistent vs. ephemeral compute.                      | Q: Why use Event-Driven over Request-Driven? A: For real-time, decoupled systems.                                     |
| Pub/Sub                            | Broadcasts messages to multiple subscribers.                                     | Google Pub/Sub, Redis Pub/Sub                                                    | Scalable, decoupled event distribution.                                                   | Use Google Pub/Sub API or Redis `PUBLISH`/`SUBSCRIBE`.                                               | Systems requiring event broadcasting.                                                              | Pub/Sub vs. Queue: Many-to-many vs. one-to-one; Google vs. Redis: Managed vs. lightweight.                             | Q: Why use Pub/Sub over Message Queue? A: For broadcasting events to multiple subscribers.                             |

---

## Global Coordination

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Consensus Algorithm                | Achieves agreement on state across nodes.                                        | Paxos, Raft                                                                      | Reliable leader election (e.g., etcd).                                                    | Use Raft in Consul; implement Paxos for custom systems.                                              | Distributed systems requiring consensus.                                                            | Paxos vs. Raft: Complexity vs. readability; vs. Locking: State vs. access control.                                     | Q: Why use Raft over Paxos? A: For simpler implementation and better readability.                                     |
| Distributed Locking                | Ensures exclusive resource access across nodes.                                  | Zookeeper, Redis                                                                 | Prevents race conditions (e.g., Redis locks).                                             | Use Zookeeper locks or Redis `SETNX` with expiry.                                                    | Systems requiring mutual exclusion.                                                                | Locking vs. Consensus: Access vs. state; Zookeeper vs. Redis: Robust vs. lightweight.                                  | Q: Why use Zookeeper over Redis for locking? A: For stronger consistency guarantees.                                  |
| CAP Theorem                        | Framework balancing Consistency, Availability, Partition Tolerance.              | Understand tradeoffs                                                             | Guides design (CP: banking, AP: social).                                                  | Test with Jepsen for consistency under partitions.                                                   | Distributed system design.                                                                          | CAP vs. ACID: Distributed vs. single-node; CP vs. AP: Accuracy vs. uptime tradeoffs.                                   | Q: Can a system be CA in CAP? A: No, in a distributed system, partition tolerance is mandatory.                        |

---

## Other Techniques

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Consistent Hashing                 | Distributes data with minimal reshuffling.                                       | Redis Cluster, DynamoDB                                                          | Reduces remapping (e.g., CDNs).                                                           | Implement hash rings in Redis Cluster or DynamoDB.                                                   | Distributed systems requiring minimal data movement.                                                | Consistent vs. Simple Hashing: Minimal movement vs. full rehash; vs. Sharding: Dynamic vs. static split.               | Q: Why use Consistent Hashing over Sharding? A: To minimize data movement during scaling.                              |
| Rate Limiting                      | Caps request frequency to prevent overload.                                      | Token Bucket, Leaky Bucket                                                       | Ensures fairness, prevents abuse (APIs).                                                  | Use Redis with Lua for Token Bucket; Nginx for Leaky Bucket.                                         | APIs requiring request throttling.                                                                 | Token vs. Leaky Bucket: Burst allowance vs. steady rate; vs. Circuit Breaker: Prevention vs. failure response.          | Q: Why use Token Bucket over Leaky Bucket? A: To allow burst requests within limits.                                   |
| Fault Tolerance                    | Maintains operation despite failures.                                            | Replication, Failover                                                            | High availability (e.g., YouTube).                                                        | Replicate with MySQL; failover with HAProxy.                                                         | Systems requiring high availability.                                                                | Replication vs. Failover: Data vs. service continuity; vs. Circuit Breaker: Proactive vs. reactive resilience.          | Q: Why use Replication over Failover? A: To ensure data continuity, not just service availability.                     |
| Circuit Breaker                    | Halts requests to failing services.                                              | Hystrix, Resilience4j                                                            | Prevents cascading failures (microservices).                                              | Use Resilience4j in Spring Boot; monitor with metrics.                                               | Microservices requiring failure isolation.                                                         | Circuit Breaker vs. Rate Limiting: Failure vs. usage control; Hystrix vs. Resilience4j: Monolithic vs. lightweight.     | Q: Why use Circuit Breaker over Rate Limiting? A: To prevent cascading failures, not just limit requests.              |

---

## Architectural Patterns

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Microservices                      | Small, autonomous services communicating via APIs.                               | REST/gRPC, Docker, Kubernetes                                                    | Independent scaling, deployment (Netflix).                                                | Dockerize services; orchestrate with Kubernetes; use gRPC.                                           | Large, complex systems requiring independent scaling.                                               | Microservices vs. Monolith: Granularity vs. simplicity; vs. Serverless: Persistent vs. ephemeral.                      | Q: Why use Microservices over Monolith? A: For independent scaling and deployment.                                    |
| Serverless                         | Event-driven compute without server management.                                  | AWS Lambda, Google Cloud Functions                                               | Cost-efficient, auto-scaling (sporadic loads).                                            | Deploy Lambda with S3 triggers; use API Gateway.                                                     | Systems with sporadic workloads.                                                                   | Serverless vs. Microservices: No ops vs. control; Lambda vs. GCF: AWS ecosystem vs. Google integration.                | Q: Why use Serverless over Microservices? A: For cost efficiency and auto-scaling.                                    |
| Event-Driven                       | Systems reacting to asynchronous events.                                         | Kafka, RabbitMQ                                                                  | Decoupled, real-time (Uber).                                                              | Use Kafka for streams; process with consumer groups.                                                 | Real-time, decoupled systems.                                                                      | Event-Driven vs. Request-Driven: Async vs. sync; Kafka vs. RabbitMQ: Streams vs. queues.                               | Q: Why use Event-Driven over Request-Driven? A: For real-time, decoupled systems.                                     |

---

## System Design Building Blocks

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| APIs                               | Interfaces for programmatic interaction.                                         | REST, gRPC                                                                       | REST: simple, gRPC: performant.                                                           | Build REST with FastAPI; gRPC with Protobuf.                                                         | General-purpose APIs.                                                                              | REST vs. gRPC: Human-readable vs. binary; vs. GraphQL: Fixed vs. flexible endpoints.                                   | Q: Why use gRPC over REST? A: For low-latency, strongly-typed APIs.                                                  |
| Content Delivery Network (CDN)     | Edge servers caching static content globally.                                    | Cloudflare, Akamai                                                               | Lowers latency, offloads origin (e.g., Netflix).                                          | Configure Cloudflare with origin pull; cache static files.                                           | Global content delivery.                                                                           | CDN vs. Reverse Proxy: Global vs. local; Cloudflare vs. Akamai: Ease vs. enterprise features.                          | Q: Why use CDN over Reverse Proxy? A: For global content caching and lower latency.                                   |
| Proxy vs Reverse Proxy             | Proxy forwards client requests; reverse proxy distributes to servers.            | Nginx, HAProxy                                                                   | Proxy: client-side, Reverse: server-side load balancing.                                  | Use Nginx as reverse proxy with upstreams; proxy via client configs.                                 | Systems requiring traffic routing.                                                                 | Proxy vs. Reverse: Outbound vs. inbound; Nginx vs. HAProxy: General vs. high-performance balancing.                     | Q: Why use Reverse Proxy over Proxy? A: For server-side load balancing and traffic distribution.                       |
| Domain Name System (DNS)           | Resolves domain names to IP addresses.                                           | AWS Route 53, Cloudflare DNS                                                     | Fast, reliable name resolution.                                                           | Set Route 53 with geo-DNS; use Cloudflare for DDoS protection.                                       | Systems requiring reliable DNS resolution.                                                         | DNS vs. CDN: Resolution vs. delivery; Route 53 vs. Cloudflare: AWS-native vs. security focus.                          | Q: Why use Route 53 over Cloudflare DNS? A: For AWS-native integration and advanced routing.                           |
| API Gateway                        | Centralized entry point for API management.                                      | Kong, AWS API Gateway                                                            | Handles auth, throttling, routing (e.g., microservices).                                  | Deploy Kong with plugins; use AWS Gateway with Lambda.                                               | Microservices requiring centralized API management.                                                | Gateway vs. Reverse Proxy: API logic vs. traffic; Kong vs. AWS: Open-source vs. managed.                               | Q: Why use API Gateway over Reverse Proxy? A: For API-specific features like auth and throttling.                      |

---

## Tradeoffs

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Vertical vs Horizontal Scaling     | Vertical: bigger machine; Horizontal: more machines.                             | Vertical for power, Horizontal for distribution                                  | Vertical: simple, Horizontal: scalable.                                                   | Benchmark with JMeter; simulate with Kubernetes.                                                     | Systems requiring scalability.                                                                      | Vertical vs. Horizontal: Capex vs. opex; vs. Sharding: Hardware vs. data split.                                        | Q: Why use Horizontal Scaling over Vertical? A: For unlimited scalability and fault tolerance.                         |
| Concurrency vs Parallelism         | Concurrency: task switching; Parallelism: simultaneous execution.                | Concurrency for multitasking, Parallelism for speed                              | Concurrency: responsiveness, Parallelism: throughput.                                     | Profile with `perf` or `concurrent.futures` (Python).                                                | Systems requiring multitasking or high throughput.                                                 | Concurrency vs. Parallelism: Logical vs. physical; vs. Async: Single-thread vs. multi-thread.                           | Q: Why use Concurrency over Parallelism? A: For responsiveness in single-threaded systems.                            |
| Long Polling vs WebSockets         | Long Polling: HTTP waits; WebSockets: persistent connection.                     | Long Polling for legacy, WebSockets for real-time                                | Long Polling: compatible, WebSockets: efficient.                                          | Test with Postman (Long Polling) vs. `ws` (WebSockets).                                              | Real-time communication systems.                                                                    | Long Polling vs. WebSockets: Overhead vs. persistence; vs. Server-Sent Events: Client vs. server push.                 | Q: Why use WebSockets over Long Polling? A: For persistent, low-latency communication.                                |
| Batch vs Stream Processing         | Batch: processes chunks; Stream: real-time flow.                                 | Batch for datasets, Stream for real-time                                         | Batch: analytics, Stream: immediacy.                                                      | Compare Spark (batch) vs. Kafka Streams (stream).                                                    | Systems requiring analytics or real-time processing.                                                | Batch vs. Stream: Latency vs. throughput; vs. Event-Driven: Scheduled vs. triggered.                                    | Q: Why use Stream Processing over Batch? A: For real-time insights and low-latency processing.                        |
| Stateful vs Stateless Design       | Stateful: retains context; Stateless: no memory.                                 | Stateful for sessions, Stateless for scalability                                 | Stateful: simple sessions, Stateless: scale.                                              | Simulate with Redis (stateful) vs. REST (stateless).                                                 | Systems requiring session management or scalability.                                                | Stateful vs. Stateless: Complexity vs. resilience; vs. Serverless: Persistent vs. ephemeral.                            | Q: Why use Stateless over Stateful? A: For scalability and fault tolerance.                                           |
| Strong vs Eventual Consistency     | Strong: immediate sync; Eventual: delayed sync.                                  | Strong for transactions, Eventual for scalability                                | Strong: accuracy, Eventual: performance.                                                  | Test with Jepsen or Chaos Monkey for consistency.                                                    | Systems requiring consistency or scalability.                                                       | Strong vs. Eventual: Latency vs. availability; vs. ACID: Distributed vs. local guarantees.                              | Q: Why use Eventual Consistency over Strong? A: For higher availability and performance.                              |

---

## Advanced Topics

| **Topic**                          | **What It Is**                                                                   | **What to Use?**                                                                 | **Why?**                                                                                   | **How to Achieve**                                                                                   | **When to Use?**                                                                                     | **Key Differences (Interview Qs)**                                                                                     | **Tricky Questions**                                                                                                   |
|------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Distributed Tracing                | Tracks requests across microservices.                                            | Jaeger, Zipkin                                                                   | Debugs latency, dependencies.                                                             | Use OpenTelemetry with Jaeger; visualize traces.                                                     | Microservices requiring observability.                                                              | Tracing vs. Logging: Flow vs. events; Jaeger vs. Zipkin: Deployment vs. ecosystem integration.                         | Q: Why use Jaeger over Zipkin? A: For better deployment flexibility and ecosystem integration.                         |
| Disaster Recovery                  | Restores system post-failure.                                                    | Backups, Replication, Failover                                                   | Ensures continuity (e.g., outages).                                                       | Use S3 backups, MySQL replication, HAProxy failover.                                                 | Systems requiring high availability.                                                                | DR vs. Fault Tolerance: Recovery vs. prevention; Replication vs. Backup: Live vs. offline.                              | Q: Why use Disaster Recovery over Fault Tolerance? A: For post-failure recovery, not just prevention.                  |
| Distributed Web Crawler            | Parallel web scraping across nodes.                                              | Kafka, Redis, Bloom Filters                                                      | Kafka: task queue, Bloom: deduplication.                                                  | Kafka for jobs, Redis for state, Bloom for uniqueness.                                               | Systems requiring large-scale web scraping.                                                         | Crawler vs. Storage: Processing vs. persistence; Bloom vs. HashSet: Space vs. accuracy.                                | Q: Why use Bloom Filters over HashSet? A: For space-efficient deduplication.                                          |
| Distributed Cloud Storage          | Scalable, redundant file storage.                                                | Consistent Hashing, Replication, Sharding                                        | Fault-tolerant scale (e.g., S3).                                                          | Use hash rings, replicate with HDFS, shard data.                                                     | Systems requiring scalable, fault-tolerant storage.                                                | Cloud vs. Local Storage: Accessibility vs. control; Sharding vs. Replication: Split vs. copy.                           | Q: Why use Cloud Storage over Local? A: For global accessibility and fault tolerance.                                 |
| Bloom Filters                      | Probabilistic structure for set membership.                                      | Redis Bloom, custom implementation                                               | Space-efficient deduplication.                                                            | Use Redis Bloom module or `pybloomfiltermmap`.                                                       | Systems requiring space-efficient deduplication.                                                   | Bloom vs. HashSet: Probabilistic vs. exact; vs. Cache: Membership vs. full data.                                        | Q: Why use Bloom Filters over HashSet? A: For space-efficient membership checks.                                      |
| Zero-Trust Architecture            | Security model assuming no implicit trust.                                       | Istio, OAuth2                                                                    | Mitigates insider threats, breaches.                                                      | Use Istio for service mesh; OAuth2 for auth.                                                         | Systems requiring high security.                                                                   | Zero-Trust vs. Perimeter: Granular vs. boundary; Istio vs. OAuth: Network vs. identity.                                | Q: Why use Zero-Trust over Perimeter Security? A: For granular, identity-based access control.                         |
| Chaos Engineering                  | Intentionally injects failures to test resilience.                               | Chaos Monkey, Gremlin                                                            | Validates fault tolerance (e.g., Netflix).                                                | Deploy Chaos Monkey on AWS; script failure scenarios.                                                | Systems requiring resilience testing.                                                              | Chaos vs. Fault Tolerance: Testing vs. design; Chaos Monkey vs. Gremlin: Open-source vs. commercial.                    | Q: Why use Chaos Engineering over Fault Tolerance? A: To proactively test system resilience.                           |

---
